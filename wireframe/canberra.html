<!doctype html>
<html lang="en">
<head>
<title>three.js - Jotunheimen</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
    body { margin: 0; overflow: hidden; }
</style>
</head>
<body>
<div id="webgl"></div>
<script src="../lib/three.min.js"></script>
<script src="../lib/TrackballControls.js"></script> 
<script>

    var width  = window.innerWidth,
        height = window.innerHeight;

    var scene = new THREE.Scene();

    var axes = new THREE.AxisHelper(200); // The X axis is red. The Y axis is green. The Z axis is blue (up). http://threejs.org/docs/#Reference/Extras.Helpers/AxisHelper
    scene.add(axes);

    var camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.y = -200;
    camera.position.z = 100;

var scale = 500;
// x is east/red

var maxX = 150.9998611;
var minX = 147.9998611;
var unitX = (maxX - minX)/scale;
meshX = new THREE.Mesh( new THREE.SphereGeometry( 10, 16, 8 ), new THREE.MeshBasicMaterial( { color: 0xff0000 } ) );
meshX.position.x = 150;
//scene.add( meshX);

// y is north/green
var maxY = -33.0001389;
var minY = -36.0001389;
var unitY = (maxY - minY)/scale;
meshY = new THREE.Mesh( new THREE.SphereGeometry( 10, 16, 8 ), new THREE.MeshBasicMaterial( { color: 0x00ff00 } ) );
meshY.position.y = 150;
//scene.add( meshY );

var originX = 149.4998611
var originY = -34.5001389

// Z is depth/height/blue
var maxZ = 900;
var minZ = 600;

homeY = -35.24984
homeX = 149.13263
meshHome = new THREE.Mesh( new THREE.SphereGeometry( 10, 16, 8 ), new THREE.MeshBasicMaterial( { color: 0xff6600 } ) );
meshHome.position.x = (originX - homeX)/-unitX;
meshHome.position.y = (originY - homeY)/-unitY;
meshHome.position.z = 21
scene.add( meshHome );


    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);
    //renderer.shadowMapEnabled = true;
    //renderer.shadowMapSoft = true;

    loadTerrain('../assets/canberra-s1s.bin', function (data){
        //console.log(data);

        var geometry = new THREE.PlaneGeometry(scale, scale, scale-1, scale-1);
        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        for (var i = 0, l = geometry.vertices.length; i < l; i++) {
            geometry.vertices[i].z = data[i] / 65535 * 100;
        }

/*        var material = new THREE.MeshPhongMaterial({
            color: 0xdddddd, 
            wireframe: true
        });*/
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture('../assets/canberra-texture.png'),
bumpMap: THREE.ImageUtils.loadTexture('../assets/canberra-s1s.png'),
bumpScale: 0.005,
specularMap: THREE.ImageUtils.loadTexture('../assets/canberra-s1s.png'),
specular: new THREE.Color('grey')
        });


        var plane = new THREE.Mesh(geometry, material);
        plane.castShadow = true;
        plane.receiveShadow = true;
        scene.add(plane);

        var controls = new THREE.TrackballControls(camera); 

        document.getElementById('webgl').appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0x111111));

        var light = new THREE.DirectionalLight(0xffffff, 1);
        light.shadowCameraVisible = true;
        light.position.set(0,400,2000);
        scene.add(light);

        render(new Date().getTime());

        function render(t) {
            controls.update();    
	     
	// spin the camera in a circle
        //camera.position.x = -600; //Math.cos(t/1000)*600;
        //camera.position.z = 150;
        //camera.position.y = Math.sin(t/1000)*600;
        // you need to update lookAt every frame
       // camera.lookAt(scene.position);

            requestAnimationFrame(render);
            renderer.render(scene, camera);
        }

    });





    var controls = new THREE.TrackballControls(camera); 

    document.getElementById('webgl').appendChild(renderer.domElement);

    render();

    function render() {
        controls.update();    
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

    //https://github.com/mrdoob/three.js/blob/master/src/loaders/XHRLoader.js

    // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data
    function loadTerrain(file, callback) {
        var req = new XMLHttpRequest();
        req.responseType = 'arraybuffer';
        req.open('GET', file, true);
        req.onload = function(evt) {
            if (req.response) {
                callback(new Uint16Array(req.response));
            }
        };
        req.send(null);
    }

</script>
</body>
</html>
